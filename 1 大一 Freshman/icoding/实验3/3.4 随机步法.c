/*题目：

编写程序,⽣成⼀种贯穿10×10字符数组（初始时全为字符'.'）的“随机步法”。
程序必须随机地从⼀个元素“⾛到”另⼀个元素，每次都向上、向下、向左或向右移动⼀个元素位置。
已访问过的元素按访问顺序⽤字⺟A到Z进⾏标记。

下⾯是⼀个输出示例：

A	.	.	.	.	.	.	.	.	.
B	C	D	.	.	.	.	.	.	.
.	F	E	.	.	.	.	.	.	.
H	G	.	.	.	.	.	.	.	.
I	.	.	.	.	.	.	.	.	.
J	.	.	.	.	.	.	.	Z	.
K	.	.	R	S	T	U	V	Y	.
L	M	P	Q	.	.	.	W	X	.
.	N	O	.	.	.	.	.	.	.
利⽤srand函数和rand函数（⻅程序deal.c）产⽣随机数，然后查看次数除以4的余数。余数⼀共有4种可能的值（0、1、2和3），
指示下⼀次移动的4种可能⽅向。在执⾏移动之前，需要检查两项内容：⼀是不能⾛到数组外⾯，⼆是不能⾛到已有字⺟标记的位置。
只要⼀个条件不满⾜，就得尝试换⼀个⽅向移动。如果4个⽅向都堵住了，程序就必须终⽌了。下⾯是提前结束的⼀个示例:

A	B	G	H	I	.	.	.	.	.
.	C	F	O	J	K	.	.	.	.
.	D	E	N	M	L	.	.	.	.
.	.	.	.	.	.	.	.	.	.
.	.	.	.	.	.	.	.	.	.
.	.	.	.	.	.	.	.	.	.
.	.	.	.	.	.	.	.	.	.
.	.	.	.	.	.	.	.	.	.
.	.	.	.	.	.	.	.	.	.
因为Y的4个⽅向都堵住了，所以没有地⽅可以放置下⼀步的Z了。*/
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

// 定义一个二维字符数组表示地图
int main() {
  char mapp[15][15];

  // 初始化地图为全点
  for (int i = 1; i <= 10; i++) {
    for (int j = 1; j <= 10; j++) {
      mapp[i][j] = '.';
    }
  }

  // 设置随机数生成器的种子值
  srand((unsigned)time(NULL));

  // 将起始位置标记为A
  mapp[1][1] = 'A';

  // 循环移动方块，直到生成26个方块
  for (int x = 1, y = 1, t = 1; t <= 25;) {
    // 检查当前方块的四个邻接位置是否为空格
    if (x + 1 <= 10 || x - 1 >= 1 || y + 1 <= 10 || y - 1 >= 1) {
      if (mapp[x + 1][y] == '.' || mapp[x - 1][y] == '.' ||
          mapp[x][y + 1] == '.' || mapp[x][y - 1] == '.') {
        // 随机选择一个邻接位置进行移动
        int m = rand() % 4;
        int ox = x, oy = y;
        switch (m) {
        case 0:
          x++;
          break;
        case 1:
          x--;
          break;
        case 2:
          y++;
          break;
        case 3:
          y--;
          break;
        }
        // 如果移动后的位置是空的，则填充为新的方块
        if (x >= 1 && x <= 10 && y >= 1 && y <= 10 && mapp[x][y] == '.')
          mapp[x][y] = 'A' + t++;
        else {
          x = ox;
          y = oy;
        }
      } else
        break;
    } else
      break;
  }

  // 输出地图
  for (int i = 1; i <= 10; i++) {
    for (int j = 1; j <= 10; j++) {
      printf("%c	", mapp[i][j]);
    }
    printf("\n");
  }

  return 0;
}