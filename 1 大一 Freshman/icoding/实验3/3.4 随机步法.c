/*题目：

编写程序,⽣成⼀种贯穿10×10字符数组（初始时全为字符'.'）的“随机步法”。
程序必须随机地从⼀个元素“⾛到”另⼀个元素，每次都向上、向下、向左或向右移动⼀个元素位置。
已访问过的元素按访问顺序⽤字⺟A到Z进⾏标记。

下⾯是⼀个输出示例：

A	.	.	.	.	.	.	.	.	.
B	C	D	.	.	.	.	.	.	.
.	F	E	.	.	.	.	.	.	.
H	G	.	.	.	.	.	.	.	.
I	.	.	.	.	.	.	.	.	.
J	.	.	.	.	.	.	.	Z	.
K	.	.	R	S	T	U	V	Y	.
L	M	P	Q	.	.	.	W	X	.
.	N	O	.	.	.	.	.	.	.
利⽤srand函数和rand函数（⻅程序deal.c）产⽣随机数，然后查看次数除以4的余数。余数⼀共有4种可能的值（0、1、2和3），
指示下⼀次移动的4种可能⽅向。在执⾏移动之前，需要检查两项内容：⼀是不能⾛到数组外⾯，⼆是不能⾛到已有字⺟标记的位置。
只要⼀个条件不满⾜，就得尝试换⼀个⽅向移动。如果4个⽅向都堵住了，程序就必须终⽌了。下⾯是提前结束的⼀个示例:

A	B	G	H	I	.	.	.	.	.
.	C	F	O	J	K	.	.	.	.
.	D	E	N	M	L	.	.	.	.
.	.	.	.	.	.	.	.	.	.
.	.	.	.	.	.	.	.	.	.
.	.	.	.	.	.	.	.	.	.
.	.	.	.	.	.	.	.	.	.
.	.	.	.	.	.	.	.	.	.
.	.	.	.	.	.	.	.	.	.
因为Y的4个⽅向都堵住了，所以没有地⽅可以放置下⼀步的Z了。*/
#include <stdio.h>
#include <stdlib.h> //包含rand()函数
#include <time.h>
#define SIZE 12 // 中间10*10是地图，外面还有一圈

// 定义一个二维字符数组表示地图
int main() {
  char map[SIZE][SIZE];

  // 初始化地图为全点
  for (int i = 1; i < 11; i++) {
    for (int j = 1; j < 11; j++) {
      map[i][j] = '.';
    }
  }

  // 设置随机数生成器的种子值，因为时间是不断变化的，
  // 所以每次运行程序都会有不同的随机数序列，从而使最终结果不同
  srand((unsigned)time(NULL));
  // time(NULL)为当前时间戳，在time.h中

  // 将起始位置标记为A
  map[1][1] = 'A';

  // 循环移动方块，直到生成26个方块
  for (int x = 1, y = 1, num = 1; num < 26;) {
    // 检查方块四周有无空格，若有至少一个，则继续，否则，退出循环，输出地图
    if (map[x + 1][y] == '.' || map[x - 1][y] == '.' || map[x][y + 1] == '.' ||
        map[x][y - 1] == '.') {
      // 随机选择一个邻接位置进行移动
      int prevX = x, prevY = y; // 记下原位置
      int m = rand() % 4;
      switch (m) {
      case 0:
        x++;
        break;
      case 1:
        x--;
        break;
      case 2:
        y++;
        break;
      case 3:
        y--;
        break;
      }
      // 如果移动后的位置是空的，则填充为新的方块
      if (x > 0 && x < 11 && y > 0 && y < 11 && map[x][y] == '.')
        map[x][y] = 'A' + num++;
      else { // 如果移动后的位置不为空或跳出地图了，则返回刚刚的位置
        x = prevX;
        y = prevY;
      }
    } else
      break;
  }

  // 输出地图
  for (int i = 1; i < 11; i++) {
    for (int j = 1; j < 11; j++) {
      printf("%c", map[i][j]);
    }
    printf("\n");
  }

  return 0;
}