204
求倍数的和
题目描述
输入 N 个整数，计算并输出这 N 个数中 3 的倍数 之和。
输入格式
第一行是一个正整数 N，表示第二行有 N 个数。
第二行是 N 个用空格隔开的整数。
输出格式
一个整数结果。
数据范围
输入样例 1
输出样例 1
输入样例 2
0 < N < 100
0 ≤ 输入的整数 ≤ 40000
3
114514 1919 81
81
2
100 100
输出样例 2
输入样例 3
输出样例 3
205
线性表是否是非递减序列
题目描述
【定义】线性表是一种存储数据的结构，其 C 语言描述如下：
给定一个有 N 个元素的线性表，判断这个线性表是否是非递减序列。
【定义】非递减序列满足这样的条件：序列中任意相邻两项，后项不小于前项。
例如：[1 2 2 3 4 5]是非递减序列；[1 2 2 3 1 5]则不是。
输入格式
第一行是一个正整数 N，表示线性表元素的个数。
第二行是 N 个用空格隔开的整数。
0
10
1 2 3 4 5 6 7 8 9 10
// 线性表的最大容量
#define CAPACITY 128
typedef struct {
int len; // 线性表实际存储的元素个数
int data[CAPACITY]; // 数组形式的存储空间。数据存储在该数组前 len 个单元
中，后面的单元空置
} list;
输出格式
如果是非递减序列，输出字符串 yes。
如果不是，输出第一个违例的前后两项元素值，用空格隔开。
数据范围
输入样例 1
输出样例 1
输入样例 2
输出样例 2
输入样例 3
1 ≤ N ≤ CAPACITY
线性表元素是任意整数值
1
-3
yes
10
1 2 2 3 3 3 4 5 6 6
yes
10
206
指定字符的出现次数
题目描述
输入一个字符 c，随后输入一个字符串 S，找出 c 在 S 中的出现次数。
输入格式
第一行输入一个字符 c，第二行输入一个只由小写英文字母 a~z 组成的字符串 S。
输出格式
一个整数答案。
数据范围
'a' ≤ c ≤ 'z'
0 ＜ len(S) ≤ 1000
输入样例 1
s
uesutcsise
输出样例 1
3
输入样例 2
a
uestcop
输出样例 2
0
输入样例 3
w
whatifwhatifwelefttoday
输出样例 3
3
207
十进制转二进制
题目描述
十进制转二进制在计算机科学中经常用到。这里提供了一种常见的转换算法即除法取余法，
请完成该算法。
【算法】

1. 从右往左，将十进制数逐步除以 2，记录每一步的余数。
2. 将得到的余数从下往上排列，即得到二进制数的每一位。
3. 将商作为新的被除数，重复上述步骤，直到商为 0。
   【案例】以十进制数 26 为例
4. 26 ÷ 2 = 13 余 0，记录这个余数。这是最低位（最右边）。
5. 13 ÷ 2 = 6 余 1，记录这个余数。
6. 6 ÷ 2 = 3 余 0，记录这个余数。
7. 3 ÷ 2 = 1 余 1，记录这个余数。
8. 1 ÷ 2 = 0 余 1，记录这个余数。现出商为 0，计算过程结束。此时的余数是最高位
   （最左边）的。
9. 因此，26 的二进制表示为余数记录的倒序：11010。
   输入格式
   一个十进制正整数 N。
   输出格式
   N 转二进制后的结果。
   数据范围
   输入样例 1
   0 ≤ N ≤ 1000
   2
   输出样例 1
   输入样例 2
   输出样例 2
   输入样例 3
   输出样例 3
   208
   找出最小值
   题目描述
   给出 N 个非负整数，找出其中的最小值并输出。
   输入格式
   第一行是一个正整数 N，表示第二行有 N 个数。
   第二行是 N 个用空格隔开的整数。
   10
   66
   1000010
   999
   1111100111
   输出格式
   一个整数结果。
   数据范围
   输入样例 1
   输出样例 1
   输入样例 2
   输出样例 2
   输入样例 3
   输出样例 3
   209
   0 < N < 100
   0 ≤ 输入的整数 ≤ 40000
   3
   114514 1919 810
   810
   1
   2
   2
   10
   1 2 3 4 5 6 7 8 9 10
   1
   线性表插入元素
   题目描述
   【定义】线性表是一种存储数据的结构，其 C 语言描述如下：
   输入一个有 N 个元素的线性表，再输入一个位置 pos 和一个整数值 v，将 v 插入到线性表内
   部数组中下标为 pos 的地方，原有元素依次后移。
   注：插入元素后，线性表的长度要增加。
   输入格式
   输入分三行：
   第一行是一个正整数 N，表示元素的个数。
   第二行是 N 个用空格隔开的元素值。
   第三行是一个正整数 pos，一个整数 v，分别表示插入位置和插入值。两个数用空格隔开。
   测试用例保证插入位置是合理的，且不会超出容量。
   输出格式
   输出在一行的、用空格隔开的线性表的元素。
   // 线性表的最大容量
   #define CAPACITY 128
   typedef struct {
   int len; // 线性表实际存储的元素个数
   int data[CAPACITY]; // 数组形式的存储空间。数据存储在该数组前 len 个单元
   中，后面的单元空置
   } list;
   数据范围
   输入样例 1
   输出样例 1
   输入样例 2
   输出样例 2
   输入样例 3
   输出样例 3
   210
   0 < N ≤ CAPACITY
   0 ≤ pos ≤ 线性表的有效长度
   线性表元素和 v 是任意整数值
   9
   99 22 77 44 55 66 33 88 11
   0 -99
   -99 99 22 77 44 55 66 33 88 11
   9
   99 22 77 44 55 66 33 88 11
   9 -11
   99 22 77 44 55 66 33 88 11 -11
   9
   99 22 77 44 55 66 33 88 11
   4 -45
   99 22 77 44 -45 55 66 33 88 11
   大小写转换
   题目描述
   输入一个只有英文字母的字符串 S，将其中的小写字母转换成大写字母、将大写字母转换成
   小写字母输出。
   提示：小写字母的 ASCII 码比对应的大写字母 大 32。
   输入格式
   一行只有英文字母的字符串 S
   输出格式
   一行大小写转换后的字符串
   数据范围
   输入样例 1
   输出样例 1
   输入样例 2
   0 ＜ len(S) ≤ 1000
   a
   A
   abcDEF
   输出样例 2
   输入样例 3
   输出样例 3
   211
   最大公约数
   题目描述
   【定义】最大公约数( gcd )是指，两个正整数能同时被它整除的最大正整数。
   输入两个正整数 m 和 n，求其最大公约数。
   【算法】辗转相除法
   辗转相除法的具体做法是：用较大数（被除数）除以较小数（除数）；再用除数除以得到的
   余数（第一余数）；再用除第一余数除以新得到的余数（第二余数）；如此反复，直到最后
   余数是 0 为止。最后的除数就是这两个数的最大公约数。
   【案例】求 24 和 14 的最大公约数过程如下：
10. 24 ÷ 14 余 10 （第一余数）。此后， 14 是下一次的被除数， 10 是除数。
11. 14 ÷ 10 余 4 （第二余数）。此后， 10 是下一次的被除数， 4 是除数。
12. 10 ÷ 4 余 2 （第三余数）。此后， 4 是下一次的被除数， 2 是除数。
13. 4 ÷ 2 余 0 （第四余数）。此时，除数 2 就是 24 和 14 的 gcd 。
    ABCdef
    ourUESTC
    OURuestc
    输入格式
    两个正整数 m 和 n（不保证 m 一定小于 n），用空格隔开。
    输出格式
    m 和 n 的最大公约数。
    数据范围
    输入样例 1
    输出样例 1
    输入样例 2
    输出样例 2
    输入样例 3
    输出样例 3
    0 < n ≤ 1000
    0 < m ≤ 1000
    5 9
    1
    24 64
    8
    580 290
    290
    212
    找出最大值
    题目描述
    输入 N 个非负整数，找出其中的最大值并输出。
    输入格式
    第一行是一个正整数 N，表示第二行有 N 个数。
    第二行是 N 个用空格隔开的整数。
    输出格式
    一个整数结果。
    数据范围
    输入样例 1
    输出样例 1
    输入样例 2
    0 < N < 100
    0 ≤ 输入的整数 ≤ 40000
    3
    114514 1919 810
    114514
    1
    2
    输出样例 2
    输入样例 3
    输出样例 3
    213
    线性表删除元素
    题目描述
    【定义】线性表是一种存储数据的结构，其 C 语言描述如下：
    输入一个有 N 个元素的线性表，输入一个位置 pos，将线性表内部数组中下标为 pos 的元
    素删除，原有元素依次前移。
    注：插入元素后，线性表的长度要减小。
    2
    10
    1 2 3 4 5 6 7 8 9 10
    10
    // 线性表的最大容量
    #define CAPACITY 128
    typedef struct {
    int len; // 线性表实际存储的元素个数
    int data[CAPACITY]; // 数组形式的存储空间。数据存储在该数组前 len 个单元
    中，后面的单元空置
    } list;
    输入格式
    输入分三行：
    第一行是一个正整数 N，表示元素的个数。
    第二行是 N 个用空格隔开的元素值。
    第三行是一个正整数 pos，表示删除位置。
    测试用例保证删除位置是合理的。
    输出格式
    输出在一行。其中，第一值是刚删除的元素的值，此后是用空格隔开的线性表的元素。
    数据范围
    输入样例 1
    输出样例 1
    输入样例 2
    0 < N ≤ CAPACITY
    0 ≤ pos ≤ 线性表的有效长度
    线性表元素是任意整数值
    9
    99 22 77 44 55 66 33 88 11
    0
    99 22 77 44 55 66 33 88 11
    9
    99 22 77 44 55 66 33 88 11
    8
    输出样例 2
    输入样例 3
    输出样例 3
    214
    逆序输出字符串
    题目描述
    输入一个字符串，然后逆序输出它。
    输入格式
    一行字符串。
    输出格式
    一行逆序的字符串。
    数据范围
    11 99 22 77 44 55 66 33 88
    9
    99 22 77 44 55 66 33 88 11
    4
    55 99 22 77 44 66 33 88 11
    0 ＜ len(S) ≤ 1000
    输入样例 1
    输出样例 1
    输入样例 2
    输出样例 2
    输入样例 3
    输出样例 3
    215
    没电梯真的很烦
    问题描述
    我每次到二教上课都会遇到一堆人排电梯，遂走楼梯。走楼梯每次上台阶有两种走法：
14. 向上走一阶;
15. 向上走两阶。
    请问我走 n 级阶梯一共有多少种走法？
    a
    a
    abcdef
    fedcba
    1234cba
    abc4321
    【算法】一种经典的动态规划思路是：假设我们要走到第 n 层台阶，我的最后一步有两种决
    策，一个是走一步，另一个是走两步，所以有：
    到达第 n 层的方法 = 到达第 n-1 层的方法 + 到达第 n-2 层的方法
    依次类推可得解。
    以 n=5 为例来演示这个算法。
    可以写出有以下八种走法：
    由上述算法可得：设 f(n) 表示走到第 n 阶的走法数。
16. 显然有： f(1)=1, f(2)=2
17. f(3)=f(1)+f(2)=3
18. f(4)=f(2)+f(3)=5
19. f(5)=f(3)+f(4)=8
    综上可得：
    f(n) = f(n-2) + f(n-1), n \geq 3
    f(1)=1
    f(2)=2
    输入格式
    一个正整数 n。
    1+1+1+1+1
    1+1+1+2
    1+1+2+1
    1+2+1+1
    2+1+1+1
    1+2+2
    2+1+2
    2+2+1
    输出格式
    一个正整数，即总的走法数。
    数据范围
    输入样例 1
    输出样例 1
    输入样例 2
    输出样例 2
    输入样例 3
    输出样例 3
    0 ≤ N ≤ 30
    5
    8
    2
    2
    30
    1346269
