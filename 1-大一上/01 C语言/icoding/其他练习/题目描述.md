208

找出最小值

## 题目描述

给出 N 个**非负**整数，找出其中的**最小值**并输出。

## 输入格式

第一行是一个正整数 N，表示第二行有 N 个数。

第二行是 N 个用空格隔开的整数。

## 输出格式

一个整数结果。

## 数据范围

```
0 < N < 100
0 ≤ 输入的整数 ≤ 40000
```

## 输入样例 1

```
3
114514 1919 810
```

## 输出样例 1

```
810
```

## 输入样例 2

```
1
2
```

## 输出样例 2

```
2
```

## 输入样例 3

```
10
1 2 3 4 5 6 7 8 9 10
```

## 输出样例 3

```
1
```

209

线性表插入元素

## 题目描述

【定义】线性表是一种存储数据的结构，其 C 语言描述如下：

```C
// 线性表的最大容量
#define CAPACITY  128

typedef struct {
    int len; // 线性表实际存储的元素个数
    int data[CAPACITY]; // 数组形式的存储空间。数据存储在该数组前len个单元中，后面的单元空置
} list;
```

输入一个有 N 个元素的线性表，再输入一个位置 pos 和一个整数值 v，将 v 插入到线性表内部数组中下标为 pos 的地方，原有元素依次后移。

> 注：插入元素后，线性表的长度要增加。

## 输入格式

输入分三行：

第一行是一个正整数 N，表示元素的个数。

第二行是 N 个用空格隔开的元素值。

第三行是一个正整数 pos，一个整数 v，分别表示插入位置和插入值。两个数用空格隔开。

> 测试用例保证插入位置是合理的，且不会超出容量。

## 输出格式

输出在一行的、用空格隔开的线性表的元素。

## 数据范围

```
0 < N ≤ CAPACITY
0 ≤ pos ≤ 线性表的有效长度
线性表元素和v 是任意整数值
```

## 输入样例 1

```
9
99 22 77 44 55 66 33 88 11
0 -99
```

## 输出样例 1

```
-99 99 22 77 44 55 66 33 88 11
```

## 输入样例 2

```
9
99 22 77 44 55 66 33 88 11
9 -11
```

## 输出样例 2

```
99 22 77 44 55 66 33 88 11 -11
```

## 输入样例 3

```
9
99 22 77 44 55 66 33 88 11
4 -45
```

## 输出样例 3

```
99 22 77 44 -45 55 66 33 88 11
```

210

大小写转换

## 题目描述

输入一个只有英文字母的字符串 S，将其中的小写字母转换成大写字母、将大写字母转换成小写字母输出。

提示：小写字母的 ASCII 码比对应的大写字母 **大** 32。

## 输入格式

一行只有英文字母的字符串 S

## 输出格式

一行大小写转换后的字符串

## 数据范围

```
0 ＜ len(S) ≤ 1000
```

## 输入样例 1

```
a
```

## 输出样例 1

```
A
```

## 输入样例 2

```
abcDEF
```

## 输出样例 2

```
ABCdef
```

## 输入样例 3

```
ourUESTC
```

## 输出样例 3

```
OURuestc
```

211

最大公约数

## 题目描述

【定义】最大公约数( gcd )是指，两个正整数能同时被它整除的最大正整数。

输入两个正整数 m 和 n，求其最大公约数。

【算法】辗转相除法

辗转相除法的具体做法是：用较大数（被除数）除以较小数（除数）；再用除数除以得到的余数（第一余数）；再用除第一余数除以新得到的余数（第二余数）；如此反复，直到最后余数是 0 为止。最后的除数就是这两个数的最大公约数。

【案例】求 24 和 14 的最大公约数过程如下：

1. 24 ÷ 14 余 10 （第一余数）。此后， 14 是下一次的被除数， 10 是除数。
2. 14 ÷ 10 余 4 （第二余数）。此后， 10 是下一次的被除数， 4 是除数。
3. 10 ÷ 4 余 2 （第三余数）。此后， 4 是下一次的被除数， 2 是除数。
4. 4 ÷ 2 余 0 （第四余数）。此时，除数 2 就是 24 和 14 的 gcd 。

## 输入格式

两个正整数 m 和 n（不保证 m 一定小于 n），用空格隔开。

## 输出格式

m 和 n 的最大公约数。

## 数据范围

```
0 < n ≤ 1000
0 < m ≤ 1000
```

## 输入样例 1

```
5 9
```

## 输出样例 1

```
1
```

## 输入样例 2

```
24 64
```

## 输出样例 2

```
8
```

## 输入样例 3

```
580 290
```

## 输出样例 3

```
290
```

212

找出最大值

## 题目描述

输入 N 个**非负**整数，找出其中的**最大值**并输出。

## 输入格式

第一行是一个正整数 N，表示第二行有 N 个数。

第二行是 N 个用空格隔开的整数。

## 输出格式

一个整数结果。

## 数据范围

```
0 < N < 100
0 ≤ 输入的整数 ≤ 40000
```

## 输入样例 1

```
3
114514 1919 810
```

## 输出样例 1

```
114514
```

## 输入样例 2

```
1
2
```

## 输出样例 2

```
2
```

## 输入样例 3

```
10
1 2 3 4 5 6 7 8 9 10
```

## 输出样例 3

```
10
```

213

线性表删除元素

## 题目描述

【定义】线性表是一种存储数据的结构，其 C 语言描述如下：

```C
// 线性表的最大容量
#define CAPACITY  128

typedef struct {
    int len; // 线性表实际存储的元素个数
    int data[CAPACITY]; // 数组形式的存储空间。数据存储在该数组前len个单元中，后面的单元空置
} list;
```

输入一个有 N 个元素的线性表，输入一个位置 pos，将线性表内部数组中下标为 pos 的元素删除，原有元素依次前移。

> 注：插入元素后，线性表的长度要减小。

## 输入格式

输入分三行：

第一行是一个正整数 N，表示元素的个数。

第二行是 N 个用空格隔开的元素值。

第三行是一个正整数 pos，表示删除位置。

> 测试用例保证删除位置是合理的。

## 输出格式

输出在一行。其中，第一值是刚删除的元素的值，此后是用空格隔开的线性表的元素。

## 数据范围

```
0 < N ≤ CAPACITY
0 ≤ pos ≤ 线性表的有效长度
线性表元素是任意整数值
```

## 输入样例 1

```
9
99 22 77 44 55 66 33 88 11
0
```

## 输出样例 1

```
99 22 77 44 55 66 33 88 11
```

## 输入样例 2

```
9
99 22 77 44 55 66 33 88 11
8
```

## 输出样例 2

```
11 99 22 77 44 55 66 33 88
```

## 输入样例 3

```
9
99 22 77 44 55 66 33 88 11
4
```

## 输出样例 3

```
55 99 22 77 44 66 33 88 11
```

214

逆序输出字符串

## 题目描述

输入一个字符串，然后逆序输出它。

## 输入格式

一行字符串。

## 输出格式

一行逆序的字符串。

## 数据范围

```
0 ＜ len(S) ≤ 1000
```

## 输入样例 1

```
a
```

## 输出样例 1

```
a
```

## 输入样例 2

```
abcdef
```

## 输出样例 2

```
fedcba
```

## 输入样例 3

```
1234cba
```

## 输出样例 3

```
abc4321
```

215

没电梯真的很烦

## 问题描述

我每次到二教上课都会遇到一堆人排电梯，遂走楼梯。走楼梯每次上台阶有两种走法：

1. 向上走一阶;
2. 向上走两阶。

请问我走 n 级阶梯一共有多少种走法？

【算法】一种经典的动态规划思路是：假设我们要走到第 n 层台阶，我的最后一步有两种决策，一个是走一步，另一个是走两步，所以有：

**到达第 n 层的方法 = 到达第 n-1 层的方法 + 到达第 n-2 层的方法**

依次类推可得解。

以 n=5 为例来演示这个算法。

可以写出有以下八种走法：

```
1+1+1+1+1
1+1+1+2
1+1+2+1
1+2+1+1
2+1+1+1
1+2+2
2+1+2
2+2+1
```

由上述算法可得：设 f(n) 表示走到第 n 阶的走法数。

1. 显然有： f(1)=1, f(2)=2
2. f(3)=f(1)+f(2)=3
3. f(4)=f(2)+f(3)=5
4. f(5)=f(3)+f(4)=8

综上可得：

f(n) = f(n-2) + f(n-1), n \geq 3

f(1)=1

f(2)=2

## 输入格式

一个正整数 n。

## 输出格式

一个正整数，即总的走法数。

## 数据范围

```
0 ≤ N ≤ 30
```

## 输入样例 1

```
5
```

## 输出样例 1

```
8
```

## 输入样例 2

```
2
```

## 输出样例 2

```
2
```

## 输入样例 3

```
30
```

## 输出样例 3

```
1346269
```

211

判断是否是亲密数对判断是否是亲密数对 【定义】亲密数对指的是一对正整数 m 和 n，m 的真因子之和等于 n，n 的真因子之和等于 m。其中，正整数 x 真因子 y 指得是 y < x 且 x 能被 y 整除。 输入正整数 m 和 n，判断它们是否是亲密数对。 【算法】 1. 先求 m 的真因子之和 x 2. 再求 n 的真因子之和 y 3. 如果 x == y，则 m 和 n 是亲密数对；否则不是 输入格式 两个正整数 m 和 n，用空格隔开。 输出格式 m 和 n 是亲密对，输出 n m，用空格隔开 否则输出字符串 "not"。 数据范围 0 < n ≤ 10000 0 < m ≤ 10000 输入样例 1 220 284 输出样例 1 284 220 输入样例 2 2620 2924 输出样例 2 2924 2620 输入样例 3 580 290 输出样例 3 not
