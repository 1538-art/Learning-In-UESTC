# 哈希排序（题目编号：182）

## 一、已知条件

有一个乱序的正整数数组，其长度为n，其中元素值在 1~m 之间。已知

- n和m都不太大
- n 小于 m
- 元素没有重复值，即数组中没有两个数是相同的
- 数组下标从0开始

## 二、任务描述

请设计一个算法，对上述数组进行从小到大升序排序。  
注：1. 不能用基数排序。2. 不能为m预估一个预设值

## 三、编码要求

1. 算法函数原型
`void xsort(unsigned *a, unsigned n);`
- 功能：将指定数组进行从小到大升序排序。如果数组长度为0，则函数什么都不做。
- 参数：
  - a：待排序数组
  - n：数组长度。注意：长度可能为0。
- 返回值：无
2. 编码约束
- 时间复杂度：O(m)
- 空间复杂度：无特别要求
> 提示：利用数组中无重复值的特点，将数据散列到一个长度为m的一维数组中（这里hash(K)=K），然后再依次收集到原数组中。注意：m的值未知，须编码求得。

## 四、参考解答

```c
void xsort(unsigned *a, unsigned n) {
    if (n == 0) {
        return; // 如果数组长度为0，则函数什么都不做
    }

    // 确定数组中的最大值m
    unsigned m = 0;
    for (unsigned i = 0; i < n; ++i) {
        if (a[i] > m) {
            m = a[i];
        }
    }

    // 创建一个计数数组，大小为m+1，初始化为0
    unsigned *count = (unsigned *)calloc(m + 1, sizeof(unsigned));

    // 计数每个元素出现的次数
    for (unsigned i = 0; i < n; ++i) {
        count[a[i]]++;
    }

    // 重新填充原数组
    unsigned index = 0;
    for (unsigned i = 1; i <= m; ++i) {
        while (count[i] > 0) {
            a[index++] = i;
            count[i]--;
        }
    }

    // 释放计数数组
    free(count);
}
```